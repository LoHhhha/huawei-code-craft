# 思路

## 机器人

* 预定矩阵`book:vector<vector<set<int>>>`

    * 对于场上的每一个坐标，我们申请一个集合来存储该点有机器人的帧
    * 机器人在预定路线时，将预计到达的时间写入
    * 机器人在经过路线时，擦除到达坐标的当前时间
    * 异常失败时：重新维护所有路线（避免）
    * 若需要随时改变路线，可以再对每个机器人维护一个queue，存储路径

方案1：
金钱/总时间 比最大的优先， 开始运送后-遇到比重更大的直接换 还要考虑更贵的那个物品离当前路线有多远，太远就可能不划算（或许可以换物品后再换到达的泊位）


总时间开销：找到货物+放到停泊点+（等待停泊点内的物品取走->约等于无）+轮船取走（停泊点固定）+轮船（停泊点固定）

对机器人来说 占用的是 找到货物+放到停泊点

1. 争取机器人的时间：最近哪个就放哪个
2. 争取最短时间得到最多钱：时间开销最短



## 关键信息

### 地图与坐标系

- 地图是一个 200*200 的封闭区域。**往下为 X 轴正方向**，**往右为 Y 轴正方向**。地图**左上角**坐标为原点(0,0)，右下角坐标为(199,199)。
- 地图数据中每个字符含义如下：

    - ‘.’ ： 空地
    - ‘*’ ： 海洋
    - ‘#’ ： 障碍
    - ‘A’ ： 机器人起始位置，总共 10 个。
    - ‘B’ ： 大小为 4*4，表示泊位的位置,泊位标号在后泊位处初始化。

- 感觉有可能会存在机器人开始就被困住的地图，或者是存在无法到达的泊位的地图（在init里预处理）


### 轮船与泊位

- 每艘轮船有一个容积 **capacity**(1 <= capacity <= 1000)，即最多能装的物品数
- 泊位是一个 4*4 的矩形，分为海岸和陆地部分。泊位的陆地部分可以放置货物，泊位的海岸部分可以放轮船。用五个整数表示一个泊位：
  
    - **id**(0 <= id < 10)为该泊位的唯一标号
    - **(x,y)**表示该泊位的左上角坐标，即该泊位的右下角坐标为(x+3,y+3)
    - **time**(1 <= time <= 1000) 表示该泊位轮船运输到虚拟点的时间(虚拟点移动到泊位的时间同)，即产生价值的时间，时间用帧数表示。
    - **Velocity**(1 <= Velocity <= 5)表示该泊位的装载速度，即每帧可以装载的物品数，单位是：个。
   
- 轮船在泊位间的移动时间为 **500 帧(10s)** ，轮船运输到虚拟点的时间为 **time**


### 物品

- 每个物品会在指定位置停留 1000 帧(20s) 的时间
- 资金会在轮船运输至虚拟点的帧时刻完成（最后时刻可以直接让轮船冲刺到虚拟点）


### 机器人

- 如果机器人碰撞到了墙壁或海（即机器人的移动目标位置和墙壁重合）或者两个机器人相互碰撞（即两个机器人的目标位置重合），则会停在原地（未触发该机器人当前帧动作，不进行移动及取货，并有可能产生连锁反应）**20 帧(400ms)** 的时间。