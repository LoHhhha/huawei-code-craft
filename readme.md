# 思路

## 流程

### 初始化流程

1. 读入地图数据
2. 在地图上为机器人 'A' 时初始化机器人的位置
3. 读入并初始化泊位数据
4. 读入船的容量并初始化
5. 在 choose_best_berth 函数中选择 5 个最佳的泊位，并预处理每一点的 {最佳到达的泊位id, 所需时间} 信息

### 每帧流程

1. get_input 更新参数
2. checker 检查是否存在异常状态（机器人是否处于恢复状态）并处理、船是否已满、新货物广播
3. 机器人前进检查
4. 空闲机器人重新规划路线\前往待机点\待机
5. 消息处理

## 机器人

* 机器人

	```c++
	struct Robot {
		int x, y;	// 机器人当前坐标
		int packet_id;	// 0: 无货物 其他整数: 货物编号
		int status;	// 0: 恢复状态 1: 正常运行状态
	};
	```

* 预定矩阵`book:vector<vector<set<int>>>`

    * 对于场上的每一个坐标，我们申请一个集合来存储该点有机器人的帧
    * 机器人在预定路线时，将预计到达的时间写入
    * 机器人在经过路线时，擦除到达坐标的当前时间
    * 异常失败时：重新维护所有路线（避免）
    * 若需要随时改变路线，可以再对每个机器人维护一个queue，存储路径

方案1：
金钱/总时间 比最大的优先， 开始运送后-遇到比重更大的直接换 还要考虑更贵的那个物品离当前路线有多远，太远就可能不划算（或许可以换物品后再换到达的泊位）


总时间开销：找到货物+放到停泊点+（等待停泊点内的物品取走->约等于无）+轮船取走（停泊点固定）+轮船（停泊点固定）

对机器人来说 占用的是 找到货物+放到停泊点

1. 争取机器人的时间：最近哪个就放哪个
2. 争取最短时间得到最多钱：时间开销最短


## 地图

* 地图信息`graph:vector<vector<int>>`

  	* 原始地图

        - '.' ： 空地
        - '*' ： 海洋
        - '#' ： 障碍
        - 'A' ： 机器人起始位置，总共 10 个。
        - 'B' ： 大小为 4*4，表示泊位的位置,泊位标号在后泊位处初始化。

    * 对于场上的200x200的区域，保存每一个地方的信息

		| 类型 | 赋值 | 说明 |
		| ---- | ---------- | ---|
		| 障碍 | -1 | #* |
		| 空地 | 0 | . |
		| 停泊点 | 1 | B |
		| 机器人 | 2 | A |
		| 货物 | 4 | 此项不一定使用 |



## 货物

* 货物`packet`

	```c++
  struct Packet {
    int id;			// 货物id
    int x,y;		// 货物位置
    int value;		// 货物价值
    int timeout;	// 过期时间：帧
  };
	```

* 货物信息`packet:vector<Packet>`

## 停泊点

* 停泊点`Berth`

	```c++
	struct Berth {
		int x, y;			// 码头左上角坐标
		int transport_time;	// 运输到虚拟点的时间
		int loading_speed;	// 装载速度: 个/帧
	};
	```



## 编码规范

- 多写注释，说明函数的作用，参数的含义，返回值的含义
- 驼峰作为结构体定义
- 多使用空格和换行
- 使用 cin/cout 输入输出流，输出完一帧的信息后，使用 `cout << flush;` 刷新输出缓冲区（待定）
- 使用 `cerr` 输出调试信息，使用 `debug` 宏控制调试信息的输出（待定），.vscode 文件夹内已有用户代码片段，可以输入 `DEBUG` 快速生成调试信息的代码片段




## 关键信息

### 地图与坐标系

- 地图是一个 200*200 的封闭区域。**往下为 X 轴正方向**，**往右为 Y 轴正方向**。地图**左上角**坐标为原点(0,0)，右下角坐标为(199,199)。
- 地图数据中每个字符含义如下（保证机器人初始位置不会重叠，保证泊位不会重叠）：

    - '.' ： 空地
    - '*' ： 海洋
    - '#' ： 障碍
    - 'A' ： 机器人起始位置，总共 10 个。
    - 'B' ： 大小为 4*4，表示泊位的位置,泊位标号在后泊位处初始化。

- 感觉有可能会存在机器人开始就被困住的地图，或者是存在无法到达的泊位的地图（在init里预处理）




### 轮船与泊位

- 每艘轮船有一个容积 **capacity**(1 <= capacity <= 1000)，即最多能装的物品数
- 泊位是一个 4*4 的矩形，分为海岸和陆地部分。泊位的陆地部分可以放置货物，泊位的海岸部分可以放轮船。用五个整数表示一个泊位：
  
    - **id**(0 <= id < 10)为该泊位的唯一标号
    - **(x,y)**表示该泊位的左上角坐标，即该泊位的右下角坐标为(x+3,y+3)
    - **time**(1 <= time <= 1000) 表示该泊位轮船运输到虚拟点的时间(虚拟点移动到泊位的时间同)，即产生价值的时间，时间用帧数表示。
    - **Velocity**(1 <= Velocity <= 5)表示该泊位的装载速度，即每帧可以装载的物品数，单位是：个。
   
- 轮船在泊位间的移动时间为 **500 帧(10s)** ，轮船运输到虚拟点的时间为 **time**
- ==泊位上任一位置物品无限放==




### 物品

- 每个物品会在指定位置停留 1000 帧(20s) 的时间
- 资金会在轮船运输至虚拟点的帧时刻完成（最后时刻可以直接让轮船冲刺到虚拟点）
- ==物品不能中途放下==




### 机器人

- 如果机器人碰撞到了墙壁或海（即机器人的移动目标位置和墙壁重合）或者两个机器人相互碰撞（即两个机器人的目标位置重合），则会停在原地（未触发该机器人当前帧动作，不进行移动及取货，并有可能产生连锁反应）**20 帧(400ms)** 的时间。
- 对撞的两种情况，1、==前往相同地点==；2、==互相前往对方当前所在地点==
- 机器人不给指令就是静止，没有惯性



### 输入格式

- **初始化：** 选手程序初始化时，将输入 200 行*200 列的字符组成的地图数据、10 行
  的泊位数据和 1 行船的容积，然后紧接着一行 OK。

- **每一帧交互：**
    - 第一行输入 2 个整数，表示帧序号（从 1 开始递增）、当前金钱数。
    
    - 第二行输入 1 个整数，表示场上新增货物的数量 K（0<=K<=10）。
    
    - 紧接着 K 行数据，每一行表示一个新增货物，分别由如下所示的数据构成，共计 3 个数字。
    
    | 名称 | 数据类型   | 说明                 |
    | ---- | ---------- | -------------------- |
    | 坐标 | 2个整数x,y | 该货物的坐标         |
    | 金额 | 正整数     | 该货物的金额(<=200) |

    - 接下来的 10 行数据，每一行表示一个机器人，分别由如下表格中所示的数据构成，每行 4 个数字。
    
    | 名称         | 数据类型   | 说明                            |
    | ------------ | ---------- | ------------------------------- |
    | 是否携带物品 | 整数       | 0表示未携带物品 1表示携带物品. |
    | 坐标         | 2个整数x,y | 该机器人的坐标                  |
    | 状态         | 整数       | 0表示恢复状态 1表示正常运行状态 |

    - 接下来的 5 行数据，每一行表示一艘船，分别由如下表格中所示的数据构成，每行两个数字。第 i 行表示标号为 i-1 的轮船。

    | 名称   | 数据类型 | 说明                                                         |
    | ------ | -------- | ------------------------------------------------------------ |
    | 状态   | 整数     | 0表示移动(运输)中<br />1表示正常运行状态(即装货状态或运输完成状态)<br />2表示泊位外等待状态 |
    | 泊位ID | 整数     | 表示目标泊位,如果目标泊位是虚拟点,则为-1                     |

    - 最后，判题器会输出一行 OK，表示所有数据已经写入完毕。



### 输出格式

- **初始化：** 读入地图数据并完成初始化后，选手程序应当输出一行 OK，告诉判题器已就绪。

- **每一帧交互：**

  - 先进行机器人指令的输出，每行一个指令，按照 "指令 <机器人 ID> [参数 2]"的格式进行输出，机器人 ID 的取值范围是[0,9]，对应机器人的输入顺序。 支持的指令如下所示。

  | 指令 | 参数 1               | 参数            | 说明                                                         |
  | ---- | -------------------- | --------------- | ------------------------------------------------------------ |
  | move | 机器人 ID 取值[0, 9] | [0,3]之间的整数 | 0 表示右移一格 <br />1 表示左移一格 <br />2 表示上移一格 <br />3 表示下移一格 |
  | get  | 机器人 ID 取值[0, 9] | 无              | 如机器人在货物生成处，并处于未携带物品状态，则取货成功。     |
  | pull | 机器人 ID 取值[0, 9] | 无              | 如机器人在泊位处，并处于携带物品状态，则放置成功。           |
  
  - 紧接着，每行一个指令，按照"指令 <船 ID> [参数 2]"的格式进行输出，船 **ID** 的取值范围是[0,4]，对应船的输入顺序。支持的指令如下所示。
  
    | 指令 | 参数1           | 参数2             | 说明                               |
    | ---- | --------------- | ----------------- | ---------------------------------- |
    | ship | 船ID 取值[0, 4] | 泊位id 取值[0, 9] | 表示船移动到泊位ID.                |
    | go   | 船ID 取值[0, 4] | 无                | 表示船从泊位驶出至虚拟点运输货物。 |
  
  - 当你输出完所有指令后，紧跟一行 OK，表示输出结束。